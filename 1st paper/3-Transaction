Transactions

Concurrency control:

The library methods TxBegin(), TxCommit() and TxAbort() shall start a new transaction, commit a current transaction and abort the current transaction, respectively. Since the PADI-DSTM uses passive replication, with the data distributed among the workers, the transactions will use a timestamp-based concurrency control. This pessimist approach was chosen over lock-based to avoid deadlocks assuming the penalty of having more rejected write calls when conflics arise.
Timestamps for the transactions will be assigned by order of arrival of the first operation over a certain object. Meaning that if a T1 and a T2 both perform read(A), then the first to arrive to the worker server will get the lowest timestamp. In simple timestamp ordering a transaction (T2, for example) may have to wait to read, in the case that another transaction T1 < T2 (meaning with timestamp lower than), that has not yet committed, has a write timestamp WTS < T2. To reduce the amount of waiting transactions on read operations and rejected reads when they arrive too late, a multiversion timestamp ordering will be used. In figure xx there's an example of a distributed multiversion timestamp ordering. A transaction T1 reads an object A on server X and then writes to it. The server X now has a committed version of the object A. Next, a transaction T2 requests a read on object A on server X. T2 will read the A commited by T1, acquiring a read timestamp. Then tries to write to A which creates a tentative version of A. But, before T2 commits another transaction T3 tries to read A. Then T3 will read the tentative version of A written by T2 instead of waiting. Now, on another side, a transaction T4 reads an object B on server Y, that was committed by another transaction sometime before - let's call it T0 -,  and a read timestamp for that object is added on the server Y.

<indeciso>
Figure xx shows an example of the timestamp ordering for a simple transaction. Transaction T1 requests a read on object A on server X and a read timestamp for that object is added on the server X. Then a transaction T2 also requests a read on object A on server X. However T2 will have to wait because there's a non-committed tentative version of object A with a timestamp lower than T2, that is T1 < T2. After T1 commits (doesn't matter if it wrote A after reading) then T2 can proceed.


Commit protocol:

The protocol used by the system to provide atomic commits shall be the two-phase commit protocol (2PC). In our implementation the coordinator will be the one of the workers, being the one that holds the object first accessed by the current transaction. The participants of the commit phase are the remaining worker servers that hold the remaining objects used in the transaction. Since we're using timestamp ordering, the only reasons to abort a transaction will be due to a server crash. Hence, on the 2PC, if a server fails to respond to the prepare (canCommit?) message because it crashed, then the coordinator may abort the transaction.
We can picture two scenarios concerning crashing on the 2PC.
First scenario would be when a server crashes before receiving the prepare message, meaning that it would never write the modified values to the presistant storage. In this case, the server when it comes back up, it queries the coordinator for the status of the transaction. If there was no timeout, the coordinator sends another prepare to the nodes which did not reply. If the was a timeout, then the coordinator informs the node to discard any changes it made.
The second scenario would happen when a server crashes right after it writes the new values to the presistant storage. Now, when the server comes back up it again queries the coordinator for the status. If there was a timeout, the coordinator informs the node that it must discard the changes made. The difference between these two scenarios is that this time the server must rollback the changes made to the persistant storage. Hence, there needs to be a log in disk that has a history of recent operations.
